%p.lede A running river, a riveting resplendence.

%h2#what-styles-are
    %a(href='#what-styles-are' title='What Styles Are') What Styles Are

%p <abbr title='Cascading StyleSheets'>CSS</abbr>, as the name suggests, is a language for <em>styling</em> the content of a website. While HTML is about structure, CSS is about style, and the first step to understand CSS is understanding how its styles are applied to an HTML document.

%p You may remember our discussion of how webpages are constructed from way back in Chapter 2 (if you don&rsquo;t, <a href='/browsers#rendering-engines' title='A Review of Rendering Engines'>feel free to review</a>). The browser takes the HTML code and constructs a DOM tree, which is the browser&rsquo;s internal representation of a page&rsquo;s structure. It then applies styles from any stylsheets the page is using to that DOM tree, followed by flowing and painting the page.

%p Before we discuss how styles are matched to elements, let&rsquo;s look at a simple set of example CSS code that might be used for styling a post on a blog, along with the accompanying HTML:

%figure.combined-code-block
    %pre
        %code.language-markup
            :escaped
                <article class='post'>
                    <header class='post-header'>
                        <h2 class='post-title'>Are Radishes Giving You Cancer?</h2>
                    </header>
                    
                    <p>We currently have no evidence for that, so it's a solid maybe.</p>
                    
                    <footer class='post-footer'>
                        <span class='post-meta'>Posted on May 13th, 2011</span>
                    </footer>
                </article>
    %pre
        %code.language-css
            :escaped
                .post {
                    background: #fff;
                    border: 1px solid #ccc;
                    border-radius: 3px;
                    padding: 1em;
                }
                
                    .post-header {
                        border-bottom: 1px dashed #dedede;
                        padding-botton: .5em;
                    }
                    
                        .post-title {
                            font-size: 2em;
                            line-height: 1.5em;
                            font-weight: 700;
                        }
                        
                    .post-footer {
                        border-top: 1px solid #ccc;
                        padding-top: .5em;
                    }
                    
                        .post-meta {
                            font-size: .8em;
                            line-height: 1.1em;
                            font-style: italic;
                        }
                        
                        
%p There&rsquo;s a lot of stuff happening in there, so let&rsquo;s breakdown the anatomy of the above code. Each collection of styles is surrounded by curly braces and prefaced with what&rsquo;s called a <em>selector</em>. Selectors identify what HTML elements styles should be applied to. Each style within the brackets are applied to the elements that match the selector. The styles themselves are split into <em>properties</em> and <em>values</em>.

%h3 Selectors

%p There are several types of selectors:

%ol
    %li Element selectors
    %li Child selectors
    %li Adjacent sibling selectors
    %li Attribute selectors
    %li Class selectors
    %li ID selectors
    %li Pseudo-class selectors
    %li Pseudo-element selectors
    
%p Each matches elements in a specific way. Let&rsquo;s cover them one-by-one.

%h4 Element Selectors

%p These are the simplest selectors. Element selectors directly match elements by name. For example, to style the <code class='language-markup'>&lt;header&gt;</code> tag, you would use the <code class='language-css'>header</code> element selector. Element selectors are written as just the name of the element, like so:

%pre
    %code.language-css
        :escaped
            p {
               margin: 1em 0;
               font-size: 16px;
               line-height: 1.5em;
            }
            
%h4 Child Selectors

%p Child selectors style elements that match the selector to the right of the child operator, and are contained by the element to the left of the child operator. For example, the following code styles paragraphs contained by the <code class='language-markup'>&lt;section&gt;</code> tag.

%pre
    %code.language-css
        :escaped
            section > p {
                font-size: 24px;
                line-height: 1.5em;
            }
            
%h4 Adjacent Sibling Selectors

%p Adjacent sibling selectors style elements that are next to, but not contained by, the element listed to the left of the operator. For example, the following code styles a paragraph following a header:

%pre
    %code.language-css
        :escaped
            header + p {
                margin-top: -.5em;
            }
            
%h4 Attribute Selectors

%p Attribute selectors style elements that have the given attribute and (possibly) value. For example, the following styles links that open in a new tab:

%pre
    %code.language-css
        :escaped
            a[target="_blank"] {
                color: #c72f28;
            }
            
%p There are a number of types of attribute selectors, they are:

%table
    %tr
        %th Selector
        %th Behavior
    %tr
        %td <code class='language-css'>[attribute="value"]</code>
        %td Matches exact value of attribute
    %tr
        %td <code class='language-css'>[attribute~="value"]</code>
        %td Matches single value of a list of values
    %tr
        %td <code class='language-css'>[attribute|="value"]</code>
        %td Matches either exact value, or value followed by a hyphen
    %tr
        %td <code class='language-css'>[attribute^="value"]</code>
        %td Matches value starting with the given characters
    %tr
        %td <code class='language-css'>[attribute$="value"]</code>
        %td Matches value ending with the given characters
    %tr
        %td <code class='language-css'>[attribute*="value"]</code>
        %td Matches value containing the given characters
        
%h4 Class Selectors

%p Class selectors style elements based on their assigned class. The syntax of the selector is simply the class name, preceded by a period. For example, the following code styles any element with the <code class='language-css'>.header</code> class:
    
%pre
    %code.language-css
        :escaped
            .header {
                background: #0381ff;
                color: #fff;
                padding: 1em;
            }
            
%p Remember when we learned about class attributes last chapter? This is their main use: providing a styling hook for CSS.

%h4 ID Selectors

%p ID selectors are very similar to class selectors, but they style based on IDs. the following code styles an element with the ID <code class='language-css'>#header</code>:

%pre
    %code.language-css
        :escaped
            #header {
                border-bottom: 1px solid #ccc;
                padding-bottom: 1em;
                margin-bottom: 1em;
            }

%p You should generally avoid using ID selectors. They are less flexible than classes, and they can really mess with specificity (which we&rsquo;ll cover in a bit).

%h4 Pseudo-Class Selectors

%p Pseudo-classes are a collection of oddball selector modifiers that can be used to style certain specific elements. Here are the important ones, along with what they modify:
    
%table
    %tr
        %th Pseudo-Class
        %th Behavior
    %tr
        %td <code class='language-css'>:link</code>
        %td Styles a link that hasn&rsquo;t been visited yet
    %tr
        %td <code class='language-css'>:visited</code>
        %td Styles a link that has been visited
    %tr
        %td <code class='language-css'>:hover</code>
        %td Sets styles for when the element is moused-over
    %tr
        %td <code class='language-css'>:active</code>
        %td Sets styles for when an element is being clicked
    %tr
        %td <code class='language-css'>:focus</code>
        %td Sets styles for when an element has been tabbed to or clicked
    %tr
        %td <code class='language-css'>:target</code>
        %td Sets styles for when an element is accessed via a fragment identifier
    %tr
        %td <code class='language-css'>:enabled</code>
        %td Sets styles for when an element is enabled
    %tr
        %td <code class='language-css'>:disabled</code>
        %td Sets styles for when an element is disabled
    %tr
        %td <code class='language-css'>:checked</code>
        %td Sets styles for when an element has been checked
    %tr
        %td <code class='language-css'>:indeterminate</code>
        %td Sets styles for when an element is neither unchecked or checked
    %tr
        %td <code class='language-css'>:root</code>
        %td Sets styles for the document&rsquo;s root element. The <code class='language-markup'>&lt;html&gt;</code> tag in HTML.
    %tr
        %td <code class='language-css'>:first-child</code>
        %td Sets styles for the first child of a given type
    %tr
        %td <code class='language-css'>:last-child</code>
        %td Sets styles for the last child of a given type
    %tr
        %td <code class='language-css'>:nth-child(N)</code>
        %td Sets styles for the children at indices matching the given formula
    %tr
        %td <code class='language-css'>:nth-of-type(N)</code>
        %td Sets styles for children of the given type at indices matching the given formula
    %tr
        %td <code class='language-css'>:first-of-type</code>
        %td Sets styles for the first child of a given type
    %tr
        %td <code class='language-css'>:last-of-type</code>
        %td Sets styles for the last child of a given type
    %tr
        %td <code class='language-css'>:nth-last-of-type(N)</code>
        %td Like <code class='language-css'>:nth-of-type(N)</code>, but counting from the last to the first
    %tr
        %td <code class='language-css'>:nth-last-child(N)</code>
        %td Like <code class='language-css'>:nth-child(N)</code>, but counting from the last to the first
    %tr
        %td <code class='language-css'>:only-of-type</code>
        %td Sets styles for element if it is the only child of its type
    %tr
        %td <code class='language-css'>:not</code>
        %td Reverses the condition of other pseudo-classes
    %tr
        %td <code class='language-css'>:empty</code>
        %td Sets styles for elements without contents
    %tr
        %td <code class='language-css'>:lang</code>
        %td Sets styles for elements with a given set language
        
%p Pseudo-class selectors can be combined, and together give you the ability to style a large number of interesting markup cases.
    
%h4 Pseudo-Element Selectors
    
%p Pseudo-element selectors are very similar to pseudo-class selectors, except they modify the DOM by inserting new nodes that can then be styled. The available pseudo-element selectors are:
    
%table
    %tr
        %th Pseudo-element
        %th Behavior
    %tr
        %td <code class='language-css'>:first-letter</code>
        %td Styles the first letter of an element
    %tr
        %td <code class='language-css'>:first-line</code>
        %td Styles the first line of text in an element
    %tr
        %td <code class='language-css'>::selection</code>
        %td Styles the content when it is highlighted by the user
    %tr
        %td <code class='language-css'>::before</code>
        %td Creates a new element before the one being styled
    %tr
        %td <code class='language-css'>::after</code>
        %td Creates a new element after the one being styled
        
%p One thing to note is that both <code class='language-css'>::before</code> and <code class='language-css'>::after</code> must have a <code class='language-css'>content</code> property in order to appear in the document.
    
.exercise
    %h3 Exercise 4.1
    %p Write good, efficient selectors for the following cases:
    %ul
        %li A paragraph inside an aside
        %li A visited link in a div with the class <code class='language-css'>.page-nav</code>
        %li The first image in a section
        %li Every 2nd row of a table
        %li A paragraph after an <code class='language-css'>h2</code> in a section with the class <code class='language-css'>.sidebar</code>
        %li A span directly contained by a link
        
    .answer
        %h3 Answer
        %p Here&rsquo;s what I did:
        %ul
            %li <code class='language-css'>aside p</code>
            %li <code class='language-css'>div.page-nav a:visited</code>
            %li <code class='language-css'>section img:first-child</code>
            %li <code class='language-css'>tr:nth-child(2n)</code>
            %li <code class='language-css'>section.sidebar h2 + p</code>
            %li <code class='language-css'>a > span</code>
            
            
            
            
            
        



%h3 Properties and Values

%p You&rsquo;ve now learned about selectors, but selectors are only part of the equation. The other parts are properties and values. Simply put: properties are the potential styles that be modified on an HTML element, and values indicate the currently used style. There are many many properties in CSS, and many more values, so it would be unreasonable to cover them all here. Instead we will cover those needed to make a basic website, and leave discovery of the others up to your exploration.

%h4 Positioning

%p The first important property to know is the <code class='language-css'>position</code> property. There are several possible position types in CSS. They are: static, relative, absolute, and fixed.
    
%p Static positioning is the default positioning of everything in an HTML element. Static elements are placed on the page according to their width, height, border, margin, padding, as well as those values for any adjacent or containing elements.

%p Relative positioning is the same as static positioning, except that relatively positioned elements may be adjusted manually using the <code class='language-css'>top</code>, <code class='language-css'>right</code>, <code class='language-css'>bottom</code>, and <code class='language-css'>left</code> properties.
    
%p Absolute positioning is the first big variation. Absolutely positioned elements are taken out of normal document flow, and are positioned using explicit offsets relative to the closest enclosing relatively positioned element.

%p Fixed positioning is like absolute positioning, but it is always positioned offset from the <code class='language-markup'>&lt;body&gt;</code> element.

%h4 Display

%p Display is the next important property to understand. There are once again four main types: block, inline, inline-block, and none (there are others but we won&rsquo;t cover them here).

%p Block display means that the element fills up the entire width of its containing element, and doesn&rsquo;t have elements placed to the left or right of it on the page. Block positioned elements are affected by padding, margin, border, width, and height.

%p Inline display means that the element flows with adjacent elements and can be placed on the same line as them. Inline elements are not affected by margin, top/bottom padding, or width.

%p Inline-block display is similar to inline display, but the element is affected by margin, top/bottom padding, and width just like a block element is.

%p Non-displayed elements are taken out of the document entirely.

%h4 Margin, Padding, Border, Width, and Height

%p These five properties affect the size of an element. They each work slightly differently. The width and height of an element are exactly what they sound like. The padding of an element adds to the width and height according to the value it is set to. Padding directly affects width and height and the area added by padding receives the same background styles that the box does. Borders go around the padding, and receive whatever styles have been set for them. Margins go around the borders and are always transparent.

%figure.image
    %img(src='<!-- @path box-model.png -->' alt='A diagram depicting the CSS box model')
    %figcaption A diagram depicting the CSS box model
    
%h4 Font

%p There are a number of font styles, including <code class='language-css'>font-weight</code>, <code class='language-css'>font-style</code>, <code class='language-css'>font-family</code>, <code class='language-css'>font-size</code>, and <code class='language-css'>line-height</code>. Font weight determines the thickness of the text, font style sets whether the text is italicized, font family sets what typeface is used for the text, font size determines how large the text is, and line height sets the spacing above and below the text.

%h4 Color

%p Colors in CSS can be set a number of different ways. Every element can have a background color, a text color, a border color, a box shadow color, and a text shadow color. These colors can be set using hexadecimal notation, rgb, rgba, hsl, and keywords. For example, here is the color red set in all those ways:

%pre
    %code.language-css
        :escaped
            #ff0000
            rgb(255,0,0)
            rgba(255,0,0,1)
            hsl(0, 100, 50)
            red

%p In CSS, all those color declarations are equivalent.


%h3 Notes on Style Matching

%p One important thing to understand about styles is the way they are matched to elements. While as English-speakers we generally read left-to-right, styles in CSS are matched right-to-left. For example in the following code, the browser first checks if an element is a paragraph. If it is, it checks if the paragraph&rsquo;s parent is an <code class='language-markup'>&lt;article&gt;</code>.
    
%pre
    %code.language-css
        :escaped
            article p {
                color: #444;
            }

.reference-container
    %aside
        %p To learn more read this <a href='http://csswizardry.com/2011/09/writing-efficient-css-selectors/' title='Writing Efficient CSS Selectors' target='_blank'>article on selector performance</a> by Harry Roberts.
    %p This process means that some selectors have better performance than others. For example <code class='language-css'>:last-child</code> is significantly slower than <code class='language-css'>:first-child</code>. This is because <code class='language-css'>:first-child</code> only requires the browser to check previously indexed elements, while <code class='language-css'>:last-child</code> requires the browser to check an un-indexed element and then return to the original one.

.exercise
    %h3 Exercise 4.2
    %p What line in the following code matches this selector: <code class='language-css'>.posts .post:nth-of-type(2n)</code>?
    %pre
        %code.language-markup
            :escaped
                <section class='posts'>
                    <article class='post'>
                        ...
                    </article>
                    <div class='advertisement'>
                        ...
                    </div>
                    <article class='post'>
                        ...
                    </article>
                    <article class='post'>
                        ...
                    </article>
                </section>
                <article class='post'>
                    ...
                </article>
                <article class='post'>
                    ...
                </article>
    .answer
        %h3 Answer
        %p The <code class='language-markup'>&lt;article&gt;</code> tag directly below the <code class='language-html'>&lt;div&gt;</code>.
    
%ol.review
    %li.review-item
        There are a number of different selectors
    %li.review-item
        Each selector handles a unique case of markup
    %li.review-item
        Selectors are evaluated left-to-right
    %li.review-item
        Because of this, some selectors are more efficient than others
        



%h2#the-cascade
    %a(href='#the-cascade' title='The Cascade') The Cascade

%p The single most important concept to understand in CSS is <em>the cascade</em>. In CSS, any number of styles from any number of locations may apply to a single element, the cascade is a set of rules for deciding how conflicting styles are handled. Understanding it is paramount for the development of large sites where conflicts between styles are likely.

%p Before we get into the rules for the cascade, we must learn about <em>specificity</em>.

%h3 Specificity

%p Specificity is a numeric value given to each and every selector in CSS. Specificity is one of the criteria for resolving conflicts between styles. There are three levels of specificity, which we will assign the values 1, 10, and 100.

%ol
    %li Element selectors have a specificity of 1
    %li Class selectors have a specificity of 10
    %li ID selectors have a specificity of 100
    
%p When comparing conflicting styles, the one with the higher selector specificity wins. For example, in the following code the background of any <code class='language-markup'>&lt;div&gt;</code> with a <code class='language-markup'>header</code> class will be blue, not red.

%pre
    %code.language-css
        :escaped
            div.header {
                background: blue;
            }
            
            .header {
                background: red;
            }
            
%p One rule to follow is that you should generally try to minimize the specificity of your selectors. If you over-specify a selector early in a stylesheet you can develop problems when you try to overwrite those styles later on.
    
.exercise
    %h3 Exercise 4.3
    %p What are the specificity values for the following selectors?
    %ul
        %li <code class='language-css'>header .nav a</code>
        %li <code class='language-css'>header #nav a</code>
        %li <code class='language-css'>#footer #footer-nav #footer-more /* Don't do this! */</code>
    .answer
        %h3 Answer
        %ul
            %li 1 + 10 + 1 = 12
            %li 1 + 100 + 1 = 102
            %li 100 + 100 + 100 = 300
            
        
        
        
    
%h3 Rules for the Cascade

%p Now that you know what specificity is, let&rsquo;s look at the specific rules for the cascade. Styles are set in the following order:

%ol
    %li Styles closer to the end of a file
    %li Styles in a file imported later
    %li Styles with higher specificity
    %li Styles with <code class='language-css'>!important</code>
    
%p Let&rsquo;s look at some examples to clarify what these mean:

%pre
    %code.language-css
        :escaped
            .nav {
                background: red;
            }
            
            .nav {
                background: blue;
            }
            
%p In the example above, the background of any element with the class <code class='language-css'>nav</code> will be blue, because the blue background style came after the red background style.
    
%figure.combined-code-block
    %pre
        %code.language-css
            :escaped
                // From style1.css
                
                .nav {
                    background: black;
                }
                
    %pre
        %code.language-css
            :escaped
                // From style2.css
                
                .nav {
                   background: green;
                }
                
    %pre
        %code.language-markup
            :escaped
                <link rel='stylesheet/css' href='css/style1.css' />
                <link rel='stylesheet/css' href='css/style2.css' />
            
%p In this example, the background of any element with the class <code class='language-css'>nav</code> will be green, because that style is from a stylesheet imported later than the other one.

%pre
    %code.language-css
        :escaped
            .nav {
                background: white;
            }
            
            div.nav {
                background: orange;
            }

%p In this example, the background will be orange, because the orange background style is set with a more specific selector.

%pre
    %code.language-css
        :escaped
            .nav {
                background: white !important;
            }
            
            div.nav {
                background: orange;
            }
            
%p In this example, the background will be white, because although the orange background style is set with a more specific selector, the specificity is overriden by the declaration of the less specific style as <code class='language-css'>!important</code>.

%p You should now have a general sense for how the cascade works. You should experiment with styles on your own to get a better feeling for it.

%ol.review
    %li.review-item
        CSS is based on the cascade: a flexible mechanism for applying conflicting styles
    %li.review-item
        <em>Specificity</em> is a major decider in style application
    %li.review-item
        Every selector has an associated specificity value
    %li.review-item
        There are a series of rules for the cascade, each of increasing weight
    %li.review-item
        <code class='language-css'>!important</code> is useful but dangerous. Use it only as a last resort.




%h2#responsive-design
    %a(href='#responsive-design' title='Responsive Design') Responsive Design

%p One of the increasingly important concepts in CSS is called &ldquo;responsive design&rdquo;. At its core, responsive design is about creating your styles in a way that can be easily accessed from any device: desktop computer, tablet, smartphone, etc. It is not a name for a specific technology, but rather a group of technologies and concepts that make the development of cross-browser websites possible. We will not cover the entirety of responsive design here, but will explore the basic ideas and methods needs to make a site responsive.

%h3 Start With a Fluid Grid

.reference-container
    %aside
        %p For an in-depth look at fluid grids read <a href='http://alistapart.com/article/fluidgrids' title='Fluid Grids' target='_blank'>Ethan Marcotte&rsquo;s seminal work on the subject</a>.
    %p Responsive web design can be considered a series of layered concepts and technologies that build to make a truly universal site. The first layer is making your site fluid. The general concepts of a fluid site are:

%ol
    %li Start with a static grid
    %li Measure type in relative units
    %li Redo the grid you want in relative units

%p What do we mean by relative units? Well, you&rsquo;ve already seen things measured in pixels. Pixels are the basic unit of measure on the web. They represent the smallest possible division of the screen. They are relatively constant across devices. However, they are also completely inflexible. Relative units are units that are measured relative to something else. The major relative units are <code class='language-css'>em</code>s, <code class='language-css'>rem</code>s, and percentages. Before we move on to the grid itself, let&rsquo;s explain each of them.

%h4 Relative Units

%p <code class='language-css'>em</code>s are a relative unit measured in the following way. A single <code class='language-css'>em</code> is equal to the desired pixel font size divided by the font size of the closest parent. In the following example, <code class='language-css'>font-size: 1.5em</code> is equal to <code class='language-css'>24px</code> because the font size of the parent element in <code class='language-css'>16px</code>.

%pre
    %code.language-css
        :escaped
            section {
                font-size: 16px;
                line-height: 1.5em;
            }
            
                section p {
                    font-size: 1.5em;
                    line-height: 1.5em;
                }

%p But wait, what&rsquo;s up with the other <code class='language-css'>1.5em</code> values? What are they equal to? Well, here&rsquo;s the same code as before, commented with the pixel values of each relative unit.

%pre
    %code.language-css
        :escaped
            section {
                font-size: 16px;
                line-height: 1.5em; /* 24px */
            }
            
                section p {
                    font-size: 1.5em; /* 24px */
                    line-height: 1.5em; /* 36px */
                }

%p For <code class='language-css'>line-height</code>, <code class='language-css'>em</code>s are set relative to the <code class='language-css'>font-size</code> of the <em>current</em> element, not the closest parent. It&rsquo;s a little detail, but it&rsquo;t an important one to remember.

%p <code class='language-css'>rem</code>s are almost identical to <code class='language-css'>em</code>s, except that instead of being measured relative to the closest parent, they are set relative to the <code class='language-markup'>&lt;html&gt;</code> element&rsquo;s font size. They avoid a common issue with <code class='language-css'>em</code>s, which is that if you accidentally put an element that is sized using <code class='language-css'>em</code>s in another one also sized with them, the font size of the child element will be bigger than expected (because the <code class='language-css'>em</code>s compound each other). <code class='language-css'>rem</code>s are newer, and have reasonably good <a href='http://caniuse.com/#search=rem' title='Rem Support Table' target='_blank'>cross-browser support</a>, but it&rsquo;s up to you to decide whether to use them in your projects.

%p The final relative measurement is percentages, which work just like <code class='language-css'>em</code>s, except the values are multiplied by 100 (just like when you&rsquo;re converting from a number with a decimal point to a percentage in real life). Here&rsquo;s the same code as before, but with percentages:

%pre
    %code.language-css
        :escaped
            section {
                font-size: 16px;
                line-height: 150%;
            }
            
                section p {
                    font-size: 150%;
                    line-height: 150%;
                }

%p Percentages are generally more tedious to write for font sizes, and are usually reserved for things like width, height, margin, and padding.

%h4 The Actual Grid

%p Now that you know the various units of relative measure, let&rsquo;s discuss the creation of a fluid grid. The idea behind a fluid grid, is to take a static grid, and turn all the static measurements into relative ones, thus allowing the grid to shrink and grow in an organic and friendly way. That&rsquo;s it. Just make a site with static measurements, swap out the pixels for <code class='language-css'>em</code>s, <code class='language-css'>rem</code>s, and percentages, and you&rsquo;re done.

%h3 Talking to the User

%p The fluid grid approach is not perfect. It works for screen sizes relatively close to the size of the static site, but for much smaller or much larger screens you start to develop issues. What you need is a way to adapt the CSS to things like the size of the window. You need media queries.

%p Media queries are a relatively new CSS technology you can use to conditionally set styles based on things like pixel density and window width. Here&rsquo;s an example stylesheet, with a media query that adapts the site to a smaller screen.

%pre
    %code.language-css
        :escaped
            body {
                font-size: 16px;
                line-height: 1.5em;
                background: #fff;
                color: #444;
                font-family: Helvetica, Arial, sans-serif;
            }
            
                section {
                    width: 500px;
                    margin: 4em auto;
                }
                
            @media screen and (max-width: 500px) {
                section {
                    width: 90%;
                    margin: 2em auto;
                }
            }

.reference-container
    %aside
        %p Being mobile first is a really good idea. <a href='http://www.lukew.com/ff/entry.asp?1117' title='Mobile First' target='_blank'>Learn more</a> from Luke Wroblewski, the guy who wrote <a href='http://www.abookapart.com/products/mobile-first' title='Mobile First at A Book Apart' target='_blank'>the book</a> on the subject.
    %p That&rsquo;s the idea. Now you may notice that in the example above the base code is for a desktop site. That&rsquo;s all well and good, but as you develop increasingly complicated sites you can encounter problems with that approach. The styles needed for a mobile site are generally simpler than those needed for a desktop one. If you start with the desktop site, you end up having to override a lot of styles for the smaller screens. If you start with the mobile design you can simply build on it to reach the desktop one.
    
%h3 Still More To It

%p Those are the basic ideas of responsive design. There&rsquo;s a lot more to learn, but the information presented here should be enough to get you started.
            
%ol.review
    %li.review-item
        Responsive design a relatively new concept that tries to provide a strong web experience to users of any and every device.
    %li.review-item
        The precursor to responsive design was the fluid grid, which uses relative measurements to introduce flexibility to a site&rsquo;s design
    %li.review-item
        Media queries allow you to go further and actually apply styles based on the nature of the device accessing the site
    %li.review-item
        Because it&rsquo;s relatively new, responsive design is still developing, and there&rsquo;s still a lot more to learn





                







%h2#preprocessors
    %a(href='#preprocessors' title='Preprocessors') Preprocessors

%p You may have noticed during this chapter that CSS is a relatively limited language. It provides all the bare essentials needed for styling a website, but is very static and has no good system for handling abstractions. Other CSS developers noticed this too, and for the last several years a large amount of effort has been expended toward developing systems to improve or build upon CSS. The end result is a group of systems called &ldquo;CSS Preprocessors&rdquo;.

%p At their core CSS preprocessors are distinct languages that are compiled into CSS. They provide useful abstractions and tools to speed up the development of CSS, and because they become CSS in the end they require no weird shoehorning workarounds to use today.

%p The two most popular preprocessors right now are SASS and LESS. They are very similar, but with some key differences. The most important difference is that SASS runs in a Ruby-based environment (meaning it is written in Ruby, requires Ruby to run, and integrates with Ruby systems) and LESS runs in a Javascript-based environment (meaning it is written in Javascript, requires Javascript to run, and integrates with Javascript systems).

%p We will cover both SASS and LESS in this section. They are both strong tools, so which one you choose is entirely up to you.

%h3 SASS

.reference-container
    %aside
        %p See the full SASS spec at <a href='http://sass-lang.com/' title='SASS - Syntactically Awesome StyleSheets' target='_blank'>sass-lang.com</a>.
    %p As previously mentioned, SASS is Ruby-based. It offers a number of features to help you build quality sites quickly. Here is an example of the first one: nesting.

%pre
    %code.language-css
        :escaped
            section {
                padding: 1em;
                color: #444;
                
                p {
                    font-size: 16px;
                    line-height: 1.5em;
                }
            }

%p That SASS code becomes the following CSS code:

%pre
    %code.language-css
        :escaped
            section {
                padding: 1em;
                color: #444;
            }
            
            section p {
                font-size: 16px;
                line-height: 1.5em;
            }

%p As you can see, the SASS code is simpler and cleaner. Here&rsquo;s another example showing off another cool nesting feature:

%pre
    %code.language-css
        :escaped
            a {
                color: #c72f28;
                
                &:hover,
                &:focus {
                    color: #0381ff;
                }
            }
            
%p Which becomes the following:

%pre
    %code.language-css
        :escaped
            a {
                color: #c72f28;
            }
            
            a:hover,
            a:focus {
                color: #0381ff;
            }

%p In this code, the ampersand is used as a placeholder for the containing selector, allowing you to do things like you just read.

%p Another simple but useful feature is variables. Instead of manually settings things like color and font size across a number of elements, you can define a variable and just reference the variable when you want to use it. Like so:

%pre
    %code.language-css
        :escaped
            $text-color: #444;
                
            body {
                color: $text-color;
            }
            
%p You can also do mixins, which allow you to do stuff like this:

%pre
    %code.language-css
        :escaped
            @mixin box-sizing($sizing: border-box) {
                -webkit-box-sizing: $sizing;
                   -moz-box-sizing: $sizing;
                        box-sizing: $sizing;
            }
            
            * {
                @include box-sizing(border-box);
            }
            
%p Which becomes:

%pre
    %code.language-css
        :escaped
            * {
                -webkit-box-sizing: border-box;
                   -moz-box-sizing: border-box;
                        box-sizing: border-box;
            }

%p But could just as easily become:

%pre
    %code.language-css
        :escaped
            * {
                -webkit-box-sizing: content-box;
                   -moz-box-sizing: content-box;
                        box-sizing: content-box;
            }
            
%p Just by passing in a different value to the mixin!

%p As you can see, there are a number of different things available in SASS. It&rsquo;s not important that you learn all of them right now. Just having awareness of this tool can be a big help, and you may opt to try it on a future project of yours. Of course, you may opt for LESS instead.
            
    
        
%h3 LESS

.reference-container
    %aside
        %p See the full LESS spec at <a href='http://lesscss.org/' title='LESS - The Dynamic StyleSheet Language' target='_blank'>lesscss.org</a>.
    %p As previously mentioned, LESS is Javascript-based. It is incredibly similar to SASS, with just a few key differences that&rsquo;ll be covered here.
        
%p The first major difference is that variables are prefaced with an &ldquo;@&rdquo; symbol instead of the &ldquo;$&rdquo; used by SASS. Here&rsquo;s an example you saw for SASS earlier, written in LESS.

%pre
    %code.language-css
        :escaped
            @text-color: #444;
                
            body {
                color: @text-color;
            }
            
%p That turns into this:

%pre
    %code.language-css
        :escaped
            body {
                color: #444;
            }
            
%p Just like the SASS code did.

%p Another big difference is that unlike SASS, LESS mixins do not have to be prefaced with <code class='language-css'>@mixin</code>. Here is another repeat example, once again in LESS instead of SASS:
    
%pre
    %code.language-css
        :escaped
            .box-sizing(@sizing: border-box) {
                -webkit-box-sizing: @sizing;
                   -moz-box-sizing: @sizing;
                        box-sizing: @sizing;
            }
            
            * {
                .box-sizing(border-box);
            }
            
%p Those are the main differences you should be aware of right now. Like SASS, LESS has a lot more going on that has been shown here. If you&rsquo;re interested in learning more just check out the websites for SASS and LESS. They both have incredibly thorough documentation to guide you through learning everything these CSS preprocessors can do.

%ol.review
    %li.review-item
        CSS Preprocessors are languages that are turned into CSS
    %li.review-item
        Preprocessors provide useful features that aren&rsquo;t available in CSS to help you write code faster and better
    %li.review-item
        SASS and LESS are the two most popular preprocessors, and they are both very similar
    %li.review-item
        Nesting, variables, and mixins are just the basics of what SASS and LESS offer


%h2#scalable-css
    %a(href='#scalable-css' title='Scalable CSS') Scalable CSS

%p As you develop larger and more complicated websites, your CSS will likely grow a large amount. One of the challenges of large scale web development is knowing how to keep your stylesheets organized and easy to maintain. There are several popular methodoligies that provide a set of concepts and rules for organizing and structuring your styles: <abbr title='Object-Oriented CSS'>OOCSS</abbr>, <abbr title='Block-Element-Modifier'>BEM</abbr>, and <abbr title='Scalable Modular Architecture for CSS'>SMACSS</abbr>. In this section we will cover each of them; describing how they work, what&rsquo;s good about them, and what problems you may encounter when following the paradigm.

%p Same as with the preprocessors, the choice of what methodology to use is yours.

%h3 OOCSS

%p OOCSS is, understandably, all about Objects. It has two main concepts:

%ol
    %li Structure should be separated from skin
    %li Content should be separated from container
    
%p What the first one means is that you should separate the styles that determine placement on a page from those styles that deterine appearance. The second one means that instead of using the decendent selector (which is fragile and tied to the current content of a container), we should use generic class names that can be applied to whatever elements we want to style.

%p Let&rsquo;s look at a couple of examples. Here is some CSS not designed with the OOCSS paradigm in mind:

%pre
    %code.language-css
        :escaped
            .button {
            	width: 20em;
            	height: 10em;
            	padding: 1em;
            	color: #444;
            	font-family: Helvetica, Arial, sans-serif;
            }
            
            .card {
            	width: 15em;
            	overflow: hidden;
            	color: #444;
            	font-family: Helvetica, Arial, sans-serif;
            }
            
%p Here it is rewritten using OOCSS:

%pre
    %code.language-css
        :escaped
            .button {
            	width: 20em;
            	height: 10em;
            	padding: 1em;
            }
            
            .card {
            	width: 15em;
            	overflow: hidden;
            }
            
            .skin {
            	color: #444;
            	font-family: Helvetica, Arial, sans-serif;
            }
            
%p As you can see, while there is now an additional class, all the classes are more generic and reusable. If we create a new class later in the project and want it to the have the same color and font as the others, we have a class that does just that ready to go. Here&rsquo;s another example:

%pre
    %code.language-css
        :escaped
            .header h1 {
                font-size: 2em;
                line-height: 1.5em;
                font-weight: 700;
                font-family: Georgia, "Times New Roman", Times, serif;
            }
            
%p Here it is rewritten with OOCSS:

%pre
    %code.language-css
        :escaped
            .header-title {
                font-size: 2em;
                line-height: 1.5em;
                font-weight: 700;
                font-family: Georgia, "Times New Roman", Times, serif;
            }
            
%p As you can see, <code class='language-css'>.header-title</code> has the same styles, but it is more flexible because it is not tied to a specific element.
    
%h4 Advantages

%p So what are the advantages of OOCSS? Well, they are:

%ol
    %li It&rsquo;s simple
    %li It encourages code reuse
    %li It avoids HTML/CSS coupling
    
%h4 Disadvantages

%p The disadvantages are:

%ol
    %li It&rsquo;s overly vague
    %li It encourages Class-bloat in your HTML
    %li It does not prescribe CSS structure on a broader scale






%h3 BEM

%p In BEM, the components of a webpage are split into three types. They are:

%ol
    %li <strong>Blocks</strong>: The major sections of the page
    %li <strong>Elements</strong>: The parts that make up a block
    %li <strong>Modifiers</strong>: The variations of elements
    
%p Blocks are independent elements of a page that can be mixed and matched. They serve a single function, and their contents can be considered to be associated or logically connected.

%p Elements are things that only make sense within the context of a containing block. For example, you may have a &ldquo;Search&rdquo; block with an input element. Outside of the block the input element can mean anything, but in the context of the Search block it is clearly used for searching. That&rsquo;s the idea of elements.

%p Modifiers are classes that can be applied to elements and blocks to vary them as needed. They are associated to a specific element or block and do not stand on their own.

%p The interesting syntactic distinction developed for BEM is the way that classes are written. In standard BEM (although you are free to follow another pattern), the following standards exist for class creation:

%ol
    %li Elements are separated from their containing block by two underscores
    %li Modifiers are separated from their associated element or block by two hyphens

%p So, for example, a class name for an input element within a search bar with a modifier to float it to the left might be <code class='language-css'>search__input--left</code>. This may seem overly verbose, but the advantage is that the class names clearly indicate exactly what is going on. They are incredibly descriptive, and if you can handle the verbosity they may be the right choice for your project.

%h4 Advantages

%ol
    %li Clear rules for class naming
    %li Provides rules for file structure (given in the documentation)
    %li Flexible
    
%h4 Disadvantages

%ol
    %li Overly verbose
    %li Too focused on Javascript
    %li Optimized for machines, not humans


%h3 SMACSS

%p The final paradigm we will cover is called SMACSS. SMACSS breaks up styles into five distinct groups: base, layout, module, state, and theme.

%p The &ldquo;base&rdquo; group is for styles that are consistent across the site, and are largely restricted to styles using element selectors and pseudo-class selectors.

%p The &ldquo;layout&rdquo; group is for styles that define the large scale layout of the site.

%p The &ldquo;module&rdquo; group is for styles defining individual components of the site. These are the portions of the site that are layed out on the page by the layout styles. Their state changes are not defined internally, but are instead defined in the next section, which is&hellip

%p &ldquo;State&rdquo; is the section for state changes, particular those that are tied to Javascript code. Putting all the Javascript-associated CSS code in one plane helps with future updating when you want to update Javascript functionality. Instead of fishing through styles all the dependent code is in one place.

%p &ldquo;Theme&rdquo;, the final group, is optional, but is used for styles that define a theme that sits on top of the site. This is common for things like blogs where the user has the ability to restyle their site. You may or may not have a need for it on your projects.

%h4 Advantages

%ol
    %li Flexible
    %li Not necessarily verbose
    %li Keeps styles clearly organized by usage
    
%h4 Disadvantages

%ol
    %li Layout and module aren&rsquo;t always distinct
    %li Theme is an unecessary section that shouldn&rsquo;t be a main section
    %li It is overly restrictive for folder organization
    
%ol.review
    %li.review-item
        As sites grow it becomes increasingly important to have a method to manage your CSS code
    %li.review-item
        In the last few years a number of such methods have developed. OOCSS, BEM, and SMACSS are the most popular of them
    %li.review-item
        OOCSS treats everything objects, and encourages good practices like separation of content from style
    %li.review-item
        BEM&rsquo;s strict rules and syntax can be verbose, but are full of semantic meaning
    %li.review-item
        SMACSS is a mix of flexible and strict. It encourages a specific folder structure in the interest of being predictable


%h2#conclusion
    %a(href='#conclusion' title='Conclusion') Conclusion

%p As you can see, like HTML, CSS is a simple language with a surprising level of nuance. This section has not covered the entirety of the language, and you are seriously encouraged to go and experiment and research things on your own.

%ol.review
    %li.review-item
        CSS is based on selectors, properties, and values
    %li.review-item
        All selectors have a specificity value, which affects how they cascade
    %li.review-item
        Responsive design methodologies allow you to develop universal sites by directly querying the device accessing the page
    %li.review-item
        As sites grow, scalable CSS becomes an increasingly important issue. There are a number of different methodologies, each with their own advantages and disadvantages


%a.button.block(href='/conclusion' title='Conclusion') Next Chapter: Conclusion &rarr;
    





















