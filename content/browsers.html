<p class='lede'>Before the web itself are ways to get there.</p>
<h2 id='accessing-a-page'>
  <a href='#accessing-a-page' title='Accessing A Page'>Accessing A Page</a>
</h2>
<div class='reference-container'>
  <aside>
    <p>For a seriously in-depth explanation read Tali&nbsp;Garsiel&rsquo;s &ldquo;<a href='http://taligarsiel.com/Projects/howbrowserswork1.htm' title='How Browsers Work by Tali Garsiel'>How&nbsp;Browsers&nbsp;Work</a>&rdquo;.</p>
  </aside>
  <p>When you type a <abbr title='Uniform Resource Locator'>URL</abbr> into your browser&rsquo;s address bar, your browser contacts the Domain Name System. This is essentially a giant list of URLs and associated IP Addresses. Next your browser takes the IP Address given by the Domain Name System and contacts it. This IP Address is the unique identifier for a web server, which is a computer setup to handle web pages. When the web server is contacted it looks up whatever page the browser is asking for and gives it to the browser.</p>
</div>
<div class='reference-container'>
  <aside>
    <p>For more information, check out <a href='http://technet.microsoft.com/en-us/library/cc772774(v=ws.10).aspx' title='How DNS Works'>Microsoft&rsquo;s explanation</a> of DNS.</p>
  </aside>
  <p>Let&rsquo;s review:</p>
  <ul>
    <li>Your browser contacts the Domain Name System and asks for an IP Address for the URL you type in.</li>
    <li>The Domain Name System gives the browser the IP Address, and your browser goes to that address.</li>
    <li>Your browser requests the web page you want, and the web server at the IP Address gives that page to the browser.</li>
  </ul>
</div>
<p>That&rsquo;s how a page is accessed.</p>
<h2 id='browser-differences'>
  <a href='#browser-differences' title='Browser Differences'>Browser Differences</a>
</h2>
<p>That&rsquo;s a pretty standard process, and the various internet browsers around don&rsquo;t differ much in how they do all of that stuff. But when the web server gives the browser the web page you asked for, it isn't usually in a nice format the browser can immediately display. It&rsquo;s in something like HTML and CSS, which need to be processed by the browser before they can be displayed. That&rsquo;s where browsers start to get different.</p>
<div class='reference-container'>
  <aside>
    <p>Browser rendering engines have been in flux lately. If you&rsquo;re interested, <a href='http://www.theguardian.com/technology/2013/apr/05/blink-google-rendering-browser' title='The Browser Wars Are Back' target='_blank'>learn more</a>.</p>
  </aside>
  <p>Each browser contains what is called a rendering engine (or a layout engine). The rendering engine is the part of the browser that processes code and turns it into something displayable. Currently there are four main rendering engines: Webkit, Gecko, Trident, and Blink. Their usage is as follows:</p>
</div>
<ul>
  <li>Webkit: Safari and Opera</li>
  <li>Gecko: Firefox</li>
  <li>Trident: Internet Explorer</li>
  <li>Blink: Chrome</li>
</ul>
<p>Each of these rendering engines handles the rendering of web pages differently, and so results may vary between different engines.</p>
<p>But wait? Isn&rsquo;t there a specification for all this stuff? How can they all be different?</p>
<p>The answer is complicated.</p>
<div class='exercise'>
  <h3>Exercise 2.1</h3>
  <p>Do some research and make a list of three browser differences.</p>
  <div class='answer'>
    <h3>Answer</h3>
    <p>There are many different answers to this, but here are a few:</p>
    <ul>
      <li>In Firefox <code class='language-css'>line-height</code> doesn&rsquo;t affect the padding of inline elements. In other browsers it does.</li>
      <li>In Internet Explorer 7, <code class='language-css'>list-style-image</code> doesn&rsquo;t work if the list item is floated.</li>
      <li>Internet Explorer 7 doesn&rsquo;t support <code class='language-css'>min-height</code>.</li>
      <li>Safari doesn&rsquo;t support Feature Queries.</li>
      <li>Firefox supports <code class='language-css'>border-box: padding-box;</code>, but only with the <code class='language-css'>-moz-</code> prefix. Other browsers don&rsquo;t support it at all.</li>
      <li>Firefox has partial support for HTML context menus. Other browsers have none.</li>
    </ul>
    <p>These may not mean much to you now, but they should illustrate the level of difference between browser&rsquo;s HTML and CSS implementations.</p>
  </div>
</div>
<h2 id='browsers-and-the-spec'>
  <a href='#browsers-and-the-spec' title='Browsers and the Spec'>Browsers and the Spec</a>
</h2>
<div class='reference-container'>
  <aside>
    <p>Learn the history of the W3C and WHATWG in Jeremy Keith&rsquo;s &ldquo;<a href='http://alistapart.com/article/a-brief-history-of-markup' title='A Brief History of Markup, by Jeremy Keith'>A Brief History of Markup</a>&rdquo;.</p>
  </aside>
  <p>There are in fact specifications for both HTML and CSS. Both are maintained by an organization called the <abbr title='World Wide Web Consortium'>W3C</abbr> &mdash; in partnership with the <abbr title='Web Hypertext Application Technology Working Group'>WHATWG</abbr> for the HTML spec. These specifications are worked on in a collaborative process between a large number of stakeholders, and these specifications are intended to provide exact explanations of how implementors &mdash; read: people who make browsers &mdash; should handle the code they receive. However, not everything gets implemented the way the spec-writers want it to, usually due to strategic decisions by the browser makers. So we end up with a spec that generally matches what the browsers do, but with enough differences between browsers to cause some headaches.</p>
</div>
<div class='exercise' data-exercise-id='2.2'>
  <h3>Exercise 2.2</h3>
  <p>Find out what the difference is between the W3C and the WHATWG.</p>
  <div class='answer'>
    <h3>Answer</h3>
    <p>The WHATWG was made by people unhappy with the W3C. Unlike the W3C, which is a slow-moving consensus-based organization, the WHATWG is a fast-moving organization run by a single editor named Ian Hickson. While the WHATWG does discuss all proposals and receive input from many stakeholders, all decisions are subject to final approval by the editor.</p>
    <p>More simply, the WHATWG uses a &ldquo;commit then review&rdquo; methodology, while the W3C uses a &ldquo;review then commit&rdquo; one.</p>
  </div>
</div>
<div class='reference-container'>
  <aside>
    <p>Check out <a href='http://caniuse.com/' title='caniuse.com' target='_blank'>caniuse.com</a> for detailed reports on browser support.</p>
  </aside>
  <p>How do we work in a world like this? The answer is simple: <em>the spec doesn't matter, what&rsquo;s implemented does</em>.</p>
</div>
<p>That may seem counter-intuitive, but remember, the spec isn&rsquo;t for web developers, it&rsquo;s for the browser makers. No matter how great the proposed features are, if they don&rsquo;t work in a browser your site&rsquo;s users regularly use, you can&rsquo;t use them.</p>
<p>So what makes the browsers so different, and how is a page actually displayed once retrieved by the browser? The answer is rendering engines.</p>
<h2 id='rendering-engines'>
  <a href='#rendering-engines' title='Rendering Engines'>Rendering Engines</a>
</h2>
<div class='reference-container'>
  <aside>
    <p>For a more in-depth explanation, check out <a href='http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/' title='How Browsers Work - HTML5 Rocks'>&ldquo;How Browsers Work&rdquo;</a> by HTML5 Rocks.</p>
  </aside>
  <p>Rendering engines are the part of a web browser that process the files the browser retrieves and turns them into something that can be displayed. In the case of HTML and CSS, the process works like this:</p>
</div>
<figure class='image'>
  <img alt="A diagram depicting Webkit's rendering flow." src='&lt;!-- @path webkit.webp --&gt;'>
  <figcaption>
    Webkit&rsquo;s rendering flow.
  </figcaption>
</figure>
<ol>
  <li>
    First the HTML and CSS are parsed
    <ol>
      <li>The HTML is turned into a DOM tree, a tree of parent and children nodes</li>
      <li>The CSS is turned into a collection of Style Rules, also called the <abbr title='CSS Object Model'>CSSOM</abbr></li>
    </ol>
  </li>
  <li>The Style Rules are applied to the DOM tree, creating the render tree</li>
  <li>The render tree is laid out on the screen, painted, and displayed</li>
</ol>
<p>That&rsquo;s the rendering flow for Webkit, but the general flow is similar between browsers. Where the browsers truly diverge is in what HTML, CSS, and Javascript features they have implemented.</p>
<div class='exercise' data-exercise-id='2.3'>
  <h3>Exercise 2.3</h3>
  <p>Find out how the rendering flow for Gecko works. How is it different from the one shown above?</p>
  <div class='answer'>
    <h3>Answer</h3>
    <figure class='image'>
      <img alt="A diagram depicting Gecko's rendering flow." src='&lt;!-- @path gecko.jpg --&gt;'>
      <figcaption>
        Gecko&rsquo;s rendering flow.
      </figcaption>
    </figure>
    <p>The biggest difference between Webkit and Gecko&rsquo;s rendering flow is that Gecko has an intermediate phase between parsing the HTML and constructing the DOM tree, called the &ldquo;Content Sink&rdquo;.</p>
  </div>
</div>
<h2 id='caching'>
  <a href='#caching' title='Caching'>Caching</a>
</h2>
<p>In &ldquo;<a href='#accessing-a-page' title='Accessing A Page'>Accessing a Page</a>&rdquo; you learned how web browsers load pages, but that&rsquo;s now always how it works. To improve load times web browsers store documents and if those documents are recent, use them instead of accessing the page again. This is called Caching and it helps browsers speed up access to sites you visit most often. However, it can also cause development headaches when you update a page but the browser loads a cached version instead. How do we avoid that?</p>
<p>The answer is cachebusting: a practice to force the browser to load a new version of a document. There are two easy ways to implement cachebusting: query strings and mod_rewrite. The first should work no matter what server type you are using, the second is restricted to an Apache server.</p>
<div class='reference-container'>
  <aside>
    <p>The query string method is problematic. Read <a href='http://stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring' title='Revving Filenames: dont use querystring'>Steve Souders&rsquo; article</a> to learn more.</p>
  </aside>
  <p>The query string approach uses query strings &mdash; normally used for passing information between pages &mdash; to apply versions to filenames. Each time the file is updated the query string is changed. When the browser checks the cached page the query string of the old page doesn&rsquo;t match the one for the new page, so the new page is loaded.</p>
</div>
<div class='exercise' data-exercise-id='2.4'>
  <h3>Exercise 2.4</h3>
  <p>Find out what the parts of a URL are. Which part is the query string?</p>
  <div class='answer'>
    <h3>Answers</h3>
    <p>Take the URL <code class='language-http'>http://v.mzw.co.uk:80/play/index.html?id=3&lang=en#loc</code>:</p>
    <ul>
      <li>The protocol is <code class='language-http'>http</code></li>
      <li>The hostname is <code class='language-http'>v.mzw.co.uk</code></li>
      <li>The subdomain is <code class='language-http'>v</code></li>
      <li>The domain name is <code class='language-http'>mzw.co.uk</code></li>
      <li>The <abbr title='Top Level Domain'>TLD</abbr> is <code class='language-http'>uk</code></li>
      <li>The <abbr title='Second Level Domain'>SLD</abbr> is <code class='language-http'>co.uk</code></li>
      <li>The port is <code class='language-http'>80</code></li>
      <li>The path is <code class='language-http'>play</code></li>
      <li>The filename is <code class='language-http'>index.html</code></li>
      <li>The query string is <code class='language-http'>id=3&lang=en</code></li>
      <li>The fragment identifier is <code class='language-http'>loc</code></li>
    </ul>
  </div>
</div>
<p>The mod_rewrite method is similar, but actually uses different filenames &mdash; without query strings &mdash; which are rewritten in the browser to the intended filename. On an Apache server, the code to do so looks like this:</p>
<pre><code class='language-http'>&lt;IfModule mod_rewrite.c&gt;
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteRule ^(.+)\.(\d+)\.(js|css|png|jpg|gif)$ $1.$3 [L]
&lt;/IfModule&gt;</code></pre>
<p>Enable mod_rewrite on your Apache server and add that to your server configuration (either the global <code class='language-http'>httpd.conf</code> file or a local <code class='language-http'>.htaccess</code> file).</p>
<h2 id='review'>
  <a href='#review' title='Review'>Review</a>
</h2>
<ol class='review'>
  <li class='review-item'>
    Web browsers get pages by requesting an IP from the Domain Name System and then connecting to a server that returns the page.
  </li>
  <li class='review-item'>
    Browsers are all a little different, but still work on implementing the same specifications.
  </li>
  <li class='review-item'>
    Rendering engines are incredibly similar in concept, but vary widely in the way they implement the spec.
  </li>
  <li class='review-item'>
    Caching is an important method for browsers to speed up page loads, but cachebusting is often necessary when developing a website.
  </li>
  <li class='review-item'>
    Cachebusting can be achieved in several ways, each with their own pros and cons.
  </li>
</ol>
<a class='button block' href='/html' title='HTML'>Next Chapter: HTML &rarr;</a>
